<思考>
思考:
- 問題直接詢問 A2A 協定。
- A2A 協定代理 (A2A Protocol Agent) 專門設計用來回答關於 A2A 協定的問題。
- 沒有其他相關的代理。
</思考>

<選定的代理>
```json
[
  {
    "name": "A2A 協定代理",
    "prompt": "什麼是 A2A 協定？"
  }
]
```
<代理名稱="A2A 協定代理">
步驟 0<思考>
思考:
- 問題要求 A2A 協定的定義。這是一個關於 Google A2A 專案的一般性問題。
- `fetch_A2A_documentation` 工具旨在擷取整個文件，其中可能包含定義。這應該是第一個使用的工具。
- 如果在擷取的文件中沒有直接找到定義，可以使用 `search_A2A_documentation` 在文件中搜尋相關部分。
</思考>

<選定的工具>
```json
[
  {
    "name": "fetch_A2A_documentation",
    "arguments": {}
  },
  {
    "name": "search_A2A_documentation",
    "arguments": {
      "query": "什麼是 A2A 協定？"
    }
  }
]
```
</選定的工具>
先前的工具已被呼叫。
- 工具:
- 參數: {}
- 結果: # A2A (Agent2Agent) 協定高層級摘要

本專案定義並示範了 **代理對代理 (Agent2Agent, A2A) 協定**，這是一個由 Google 發起的開放標準，旨在實現不同 AI 代理系統之間的通訊和互通性。核心目標是允許基於不同框架（例如 LangGraph、CrewAI、Google ADK、Genkit）或由不同供應商建置的代理能夠發現彼此的能力、協商互動模式（文字、表單、檔案，未來可能支援音訊/視訊），並協作執行任務。

本儲存庫提供：

1.  **正式規格：** 詳細的 JSON 結構描述 (`specification/json/a2a.json`)，定義了 A2A 訊息的結構，包括請求、回應、任務狀態、產出成品和代理元資料（代理卡）。
2.  **核心概念文件（隱含）：** 主要 README 中的連結指向涵蓋代理發現、任務生命週期、成品交換、串流更新、推播通知和企業整備度的文件。
3.  **範例實作：**
    *   **通用函式庫：** 可重複使用的 Python (`samples/python/common`) 和 JavaScript/TypeScript (`samples/js/src`) 程式碼，用於建置 A2A 客戶端和伺服器、處理 JSON-RPC 通訊、任務管理以及潛在的身份驗證。
    *   **範例代理：** 將 A2A 整合到各種代理框架中的示範：
        *   **Python：** LangGraph（貨幣轉換、串流）、CrewAI（圖片生成、檔案成品）、Google ADK（費用報銷、表單處理）。
        *   **JavaScript/TypeScript：** Genkit（透過 API 取得電影資訊、使用檔案成品產生程式碼）。
    *   **範例主機：** *使用* A2A 服務的應用程式：
        *   Python 和 JS 中的 CLI，用於直接互動。
        *   一個基於 Python 的多代理協同器（使用 Google ADK），可將任務委派給其他 A2A 代理。
4.  **示範 Web 應用程式：** 一個 Web UI (`demo/ui`，可能使用 Mesop)，展示了由 A2A 協定促成的多代理互動，包括對話、任務、事件和代理發現的視覺化。它具有一個與主機代理協調的後端服務。

規格和範例中突顯的 A2A 協定的主要功能包括：透過代理卡發現代理、標準化的任務管理（傳送、取得、取消）、透過 `Parts` 和 `Artifacts` 支援不同的內容類型（文字、檔案、結構化資料）、對長時間執行任務的串流更新，以及推播通知機制。該專案是開源的，並鼓勵社群貢獻。

# A2A (Agent2Agent) 協定

## 1. 總覽

*   **專案名稱：** 代理對代理 (A2A) 協定
*   **目的：** 一個由 Google 發布的開放協定，可實現基於不同框架或由不同供應商建置的 AI 代理之間的通訊和互通性。
*   **核心目標：** 允許代理發現能力、協商互動並安全地協作執行任務。
*   **通訊：** 使用基於 HTTP(S) 的 JSON-RPC 2.0。支援標準請求/回應和用於串流的伺服器發送事件 (Server-Sent Events, SSE)。
*   **主要元件：** 規格（JSON 結構描述）、通用函式庫（Python、JS/TS）、範例代理（LangGraph、CrewAI、ADK、Genkit）、範例主機（CLI、協同器）、示範 Web 應用程式（Mesop）。

## 2. 協定規格 (`specification/json/a2a.json`)

### 2.1. 核心 JSON-RPC 結構

*   **`JSONRPCMessage`：** 請求/回應的基礎。包含 `jsonrpc: "2.0"` 和可選的 `id`。
*   **`JSONRPCRequest`：** 表示一個請求。
    *   `method`：識別操作的字串（例如 "message/send"）。
    *   `params`：包含方法參數的物件或陣列。
    *   `id`：用於請求/回應關聯的唯一識別碼（字串/數字）。對於通知，則省略/為 null。
*   **`JSONRPCResponse`：** 表示一個回應。
    *   `result`：包含成功的回應資料（可為 `null`）。與 `error` 互斥。
    *   `error`：如果請求失敗，則包含一個錯誤物件。與 `result` 互斥。
    *   `id`：必須與對應的請求 `id` 相符。
*   **`JSONRPCError`：** 表示一個錯誤。
    *   `code`：整數錯誤碼。
    *   `message`：錯誤的字串描述。
    *   `data`：可選的額外錯誤詳細資訊。

### 2.2. 關鍵 A2A 資料物件

*   **`AgentCard`：** 描述代理的元資料。通常位於 `/.well-known/agent.json`。
    *   `name`：（字串）人類可讀的名稱。
    *   `description`：（字串 | null）代理描述。
    *   `url`：（字串）代理 A2A 服務的基礎 URL 端點。
    *   `provider`：（`AgentProvider` | null）組織詳細資訊。
    *   `version`：（字串）代理/API 版本。
    *   `documentationUrl`：（字串 | null）文件連結。
    *   `capabilities`：（`AgentCapabilities`）支援的功能（串流、推播）。
    *   `authentication`：（`AgentAuthentication` | null）所需的驗證方案/憑證。
    *   `defaultInputModes`：（字串[]）預設支援的輸入類型（例如 "text"、"file"）。
    *   `defaultOutputModes`：（字串[]）預設支援的輸出類型。
    *   `skills`：（`AgentSkill[]`）特定能力的列表。
*   **`AgentCapabilities`：**
    *   `streaming`：（布林值）支援 `message/stream`。
    *   `pushNotifications`：（布林值）支援 `tasks/pushNotification/set|get`。
    *   `stateTransitionHistory`：（布林值）支援提供詳細的歷史記錄。
*   **`AgentSkill`：**
    *   `id`：（字串）唯一的技能 ID。
    *   `name`：（字串）技能名稱。
    *   `description`：（字串 | null）技能描述。
    *   `tags`：（字串[] | null）關鍵字。
    *   `examples`：（字串[] | null）使用範例。
    *   `inputModes`：（字串[] | null）覆寫此技能的預設輸入。
    *   `outputModes`：（字串[] | null）覆寫此技能的預設輸出。
*   **`Task`：** 表示由代理處理的工作單元。
    *   `id`：（字串）唯一的任務識別碼。
    *   `sessionId`：（字串 | null）將相關任務分組。
    *   `status`：（`TaskStatus`）目前的狀態和相關訊息。
    *   `artifacts`：（`Artifact[]` | null）任務產生的成品。
    *   `history`：（`Message[]` | null）（可選）為此任務交換的訊息歷史記錄（如果透過 `historyLength` 請求）。
    *   `metadata`：（物件 | null）額外的任務元資料。
*   **`TaskStatus`：**
    *   `state`：（`TaskState`）目前的生命週期狀態（列舉）。
    *   `message`：（`Message` | null）與此狀態相關的訊息（例如，進度更新、最終回應文字、輸入提示）。
    *   `timestamp`：（字串）狀態更新的 ISO 8601 時間戳。
*   **`TaskState` (列舉)：**
    *   `submitted`：已收到任務，尚未開始。
    *   `working`：正在積極處理任務。
    *   `input-required`：代理需要使用者/客戶端的進一步輸入。
    *   `completed`：任務成功完成。
    *   `canceled`：任務已取消。
    *   `failed`：任務因錯誤而失敗。
    *   `unknown`：無法確定狀態。
*   **`Message`：** 使用者和代理之間的通訊單元。
    *   `role`：（"user" | "agent"）寄件人角色。
    *   `parts`：（`Part[]`）內容部分（文字、檔案、資料）。
    *   `metadata`：（物件 | null）訊息特定的元資料。
*   **`Part` (聯合類型)：** 表示訊息或成品中的一塊內容。
    *   **`TextPart`：**
        *   `type`："text"
        *   `text`：（字串）文字內容。
    *   **`FilePart`：**
        *   `type`："file"
        *   `file`：（`FileContent`）檔案詳細資訊（位元組或 URI）。
    *   **`DataPart`：**
        *   `type`："data"
        *   `data`：（物件）結構化 JSON 資料（例如，用於表單）。
    *   `metadata`：（物件 | null）特定部分的可選元資料。
*   **`FileContent`：** 表示檔案資料。
    *   `name`：（字串 | null）檔案名稱。
    *   `mimeType`：（字串 | null）MIME 類型。
    *   `bytes`：（字串 | null）Base64 編碼的檔案內容。*與 `uri` 互斥。*
    *   `uri`：（字串 | null）指向檔案內容的 URI。*與 `bytes` 互斥。*
*   **`Artifact`：** 任務產生的成品。
    *   `name`：（字串 | null）成品名稱。
    *   `description`：（字串 | null）成品描述。
    *   `parts`：（`Part[]`）內容部分。
    *   `index`：（整數，預設為 0）順序索引，對串流/更新很有用。
    *   `append`：（布林值 | null）對於串流，表示內容是否應附加到相同索引的成品。
    *   `lastChunk`：（布林值 | null）對於串流，表示此成品的最後一塊。
    *   `metadata`：（物件 | null）成品元資料。
*   **`PushNotificationConfig`：** 推播通知的設定。
    *   `url`：（字串）代理發布通知的端點 URL。
    *   `token`：（字串 | null）代理可選包含的權杖。
    *   `authentication`：（`AuthenticationInfo` | null）代理呼叫 URL 所需的驗證詳細資訊。
*   **`TaskPushNotificationConfig`：** 將 `PushNotificationConfig` 與任務 ID 關聯。

### 2.3. A2A RPC 方法

*   **`message/send`：**（請求/回應）
    *   發送訊息以啟動或繼續任務。
    *   `params`：`TaskSendParams`（包括 `id`、`sessionId`、`message`，可選 `pushNotification`、`historyLength`、`metadata`）。
    *   `result`：`Task`（同步處理後的最終狀態）。
*   **`message/stream`：**（請求/串流）
    *   發送訊息並訂閱即時更新（透過 SSE）。
    *   `params`：`TaskSendParams`。
    *   `result`（串流事件）：`TaskStatusUpdateEvent` 或 `TaskArtifactUpdateEvent`。最終事件具有 `final: true`。
*   **`tasks/get`：**（請求/回應）
    *   擷取任務的目前狀態。
    *   `params`：`TaskQueryParams`（包括 `id`，可選 `historyLength`）。
    *   `result`：`Task`。
*   **`tasks/cancel`：**（請求/回應）
    *   請求取消正在執行的任務。
    *   `params`：`TaskIdParams`（包括 `id`）。
    *   `result`：`Task`（更新後的狀態，可能是「已取消」）或如果無法取消則為錯誤。
*   **`tasks/pushNotification/set`：**（請求/回應）
    *   設定或更新任務的推播通知設定。
    *   `params`：`TaskPushNotificationConfig`。
    *   `result`：`TaskPushNotificationConfig`（已確認的設定）。
*   **`tasks/pushNotification/get`：**（請求/回應）
    *   擷取任務目前的推播通知設定。
    *   `params`：`TaskIdParams`。
    *   `result`：`TaskPushNotificationConfig`。
*   **`tasks/resubscribe`：**（請求/串流）
    *   在連線中斷後重新訂閱任務更新（SSE）。
    *   `params`：`TaskQueryParams`。
    *   `result`（串流事件）：`TaskStatusUpdateEvent` 或 `TaskArtifactUpdateEvent`。

### 2.4. 串流更新事件（`message/stream` 或 `tasks/resubscribe` 的結果）

*   **`TaskStatusUpdateEvent`：** 表示任務狀態的變更。
    *   `id`：（字串）任務 ID。
    *   `status`：（`TaskStatus`）新的狀態物件。
    *   `final`：（布林值）如果這是任務的最終更新，則為 True。
    *   `metadata`：（物件 | null）事件元資料。
*   **`TaskArtifactUpdateEvent`：** 表示新的或更新的成品。
    *   `id`：（字串）任務 ID。
    *   `artifact`：（`Artifact`）成品資料。
    *   `final`：（布林值，對於成品通常為 false）可以與狀態同時表示結束。
    *   `metadata`：（物件 | null）事件元資料。

### 2.5. 標準錯誤碼

*   `-32700`：`JSONParseError` - 無效的 JSON 酬載。
*   `-32600`：`InvalidRequestError` - 無效的 JSON-RPC 請求物件。
*   `-32601`：`MethodNotFoundError` - 方法不存在。
*   `-32602`：`InvalidParamsError` - 無效的方法參數。
*   `-32603`：`InternalError` - 內部伺服器錯誤。

### 2.6. A2A 特定錯誤碼

*   `-32001`：`TaskNotFoundError` - 找不到指定的任務 ID。
*   `-32002`：`TaskNotCancelableError` - 任務處於最終狀態，無法取消。
*   `-32003`：`PushNotificationNotSupportedError` - 代理不支援推播通知。
*   `-32004`：`UnsupportedOperationError` - 不支援請求的操作。
*   `-32005`：`ContentTypeNotSupportedError` - 支援的內容類型不符。

## 3. 核心概念

*   **代理發現：** 客戶端透過擷取 `AgentCard` JSON（通常來自 `/.well-known/agent.json`）來尋找代理及其能力。
*   **任務生命週期：** 任務在 `TaskState` 中定義的狀態之間轉換（已提交 -> 進行中 -> [需要輸入] -> 已完成/已取消/已失敗）。
*   **通訊：** 使用包含 `Part`（文字、檔案、資料）的 `Message` 物件。任務輸出表示為 `Artifact`，也包含 `Part`。
*   **串流：** 長時間執行的任務可以透過 `message/stream` 使用 SSE 提供即時更新。更新以 `TaskStatusUpdateEvent` 和 `TaskArtifactUpdateEvent` 的形式發送。
*   **推播通知：** 代理可以使用透過 `tasks/pushNotification/set` 提供的 webhook URL 主動通知客戶端有關任務更新的資訊。支援驗證機制（例如，透過從代理的 JWKS 端點簽署的金鑰的 JWT 的持有者權杖）。
*   **身份驗證：** 在 `AgentCard` 和 `PushNotificationConfig` 中定義。可以涉及各種方案（例如，API 金鑰、OAuth、JWT）。範例使用 JWT 進行推播通知。
*   **表單：** 可以使用 `DataPart` 在訊息/成品中請求和提交結構化資料（在 ADK 範例中示範）。

## 4. 實作與範例

### 4.1. 通用函式庫

*   **Python (`samples/python/common`)**：
    *   `client/`：`A2AClient` 用於發出請求，`A2ACardResolver` 用於發現。
    *   `server/`：`A2AServer`（基於 Starlette）、`TaskManager` 基底類別、`InMemoryTaskManager`。
    *   `types.py`：對應 JSON 結構描述的 Pydantic 模型。
    *   `utils/`：用於推播通知驗證的輔助程式（JWT 簽署/驗證、JWKS 端點）。
*   **JavaScript/TypeScript (`samples/js/src`)**：
    *   `client/`：使用 `fetch` 的 `A2AClient` 實作。
    *   `server/`：`A2AServer`（基於 Express）、`TaskStore` 介面、`InMemoryTaskStore`、`FileStore`。
    *   `schema.ts`：與 JSON 結構描述相符的 TypeScript 介面。
    *   `handler.ts`、`error.ts`、`utils.ts`：伺服器的支援程式碼。

### 4.2. Python 範例

*   **位置：** `samples/python/agents/` & `samples/python/hosts/`
*   **設定：** 使用 `uv` 和 `pyproject.toml`。需要 Python >= 3.12/3.13。透過 `.env` 提供 API 金鑰。
*   **代理：**
    *   **LangGraph (`agents/langgraph`)**：貨幣轉換代理。示範工具使用、多輪（`input-required`）和**串流**（`message/stream`）。
    *   **CrewAI (`agents/crewai`)**：圖片生成代理。示範多輪和處理**檔案成品**（圖片）。
    *   **Google ADK (`agents/google_adk`)**：費用報銷代理。示範多輪和使用 `DataPart` 處理**表單**。
*   **主機：**
    *   **CLI (`hosts/cli`)**：用於與任何 A2A 代理互動的簡單命令列客戶端。支援串流和可選的推播通知接聽。
    *   **多代理協同器 (`hosts/multiagent`)**：一個基於 ADK 的「主機代理」，管理與其他 A2A 代理的連線 (`RemoteAgentConnections`) 並根據指令委派任務。

### 4.3. JavaScript/TypeScript 範例

*   **位置：** `samples/js/`
*   **設定：** 使用 `npm`/`pnpm`、`tsx`、`tsconfig.json`。需要 Node.js >= 18。透過環境變數提供 API 金鑰。框架：**Genkit**。
*   **代理 (`src/agents/`)**：
    *   **電影代理 (`movie-agent`)**：使用 TMDB API 透過 Genkit 工具回答電影問題。示範工具使用和多輪（`AWAITING_USER_INPUT` 對應到 `input-required`）。
    *   **程式碼代理 (`coder`)**：產生程式碼檔案。示範透過串流更新產生多個**檔案成品**。使用自訂 Genkit 格式 (`code-format.ts`)。
*   **主機：**
    *   **CLI (`src/cli.ts`)**：用於與 JS 代理互動的命令列客戶端。

### 4.4. 示範應用程式 (`demo/`)

*   **UI (`demo/ui`)**：使用 **Mesop** 建置的 Web 應用程式。
    *   透過主機協同器視覺化與多個代理的對話。
    *   呈現文字、圖片、表單。
    *   允許透過 URL 動態註冊代理。
    *   提供任務列表和事件日誌的檢視。
*   **服務 (`demo/ui/service`)**：Mesop UI 的後端服務。
    *   `server/`：管理對話、路由訊息、與主機代理（`ADKHostManager` 或 `InMemoryFakeAgentManager`）介接。
    *   `client/`：UI 用於與其*自己的*後端服務通訊的客戶端。

## 5. 開發與設定

*   **先決條件：** Python (>=3.12 或 3.13)、Node.js (>=18)、`uv` (用於 Python)、`npm`/`pnpm` (用於 JS)。
*   **API 金鑰：** 存取 LLM 所需（例如 `GOOGLE_API_KEY`、`TMDB_API_KEY`），通常透過 `.env` 檔案或環境變數設定。
*   **執行範例：** 通常涉及執行代理伺服器（`uv run ...` 或 `npm run ...`），然後執行主機客戶端/應用程式（例如 `uv run hosts/cli --agent <agent_url>`）。

## 6. 貢獻

*   請參閱 `CONTRIBUTING.md`。
*   GitHub discussion 可作為主要溝通方式。
*   GitHub issues 用於錯誤回報和功能請求。
*   Google Form 用於私人意見回饋。


- 工具:
- 參數: {'query': '什麼是 A2A 協定？'}
- 結果: ## 查詢

什麼是 A2A 協定？.

## 回應

### 來源：
重要提示：您可以使用 fetch_url_content 工具擷取任何來源的完整內容

#### (google/A2A/docs/index.md)[https://raw.githubusercontent.com/google/A2A/main/docs/index.md] (分數: 0.63)
-

**代理對代理 (A2A) 協定** 是一個開放標準，旨在實現 AI 代理之間的無縫通訊和協作。在一個代理使用不同框架和由不同供應商建置的世界中，A2A 提供了一種通用語言，打破了孤島並促進了互通性。

- [部落格文章：宣布代理對代理協定 (A2A)](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)
- [觀看 A2A 示範影片](https://storage.googleapis.com/gweb-developer-goog-blog-assets/original_videos/A2A_demo_v4.mp4)

![A2A 主圖](assets/a2a-main.png){width="50%"}
{style="text-align: center; margin-bottom:1em; margin-top:2em;"}

---

#

#### (google/A2A/docs/specification.md)[https://raw.githubusercontent.com/google/A2A/main/docs/specification.md] (分數: 0.63)
-

代理對代理 (A2A) 協定是一個開放標準，旨在促進獨立、可能不透明的 AI 代理系統之間的通訊和互通性。在一個代理可能使用不同框架、語言或由不同供應商建置的生態系統中，A2A 提供了一種通用語言和互動模型。

本文件提供了 A2A 協定的詳細技術規格。其主要目標是使代理能夠：

- 發現彼此的能力。
- 協商互動模式（文字、檔案、結構化資料）。
- 管理協作任務。
- 安全地交換資訊以實現使用者目標 **而無需存取彼此的內部狀態、記憶體或工具。**

#

#### (google/A2A/llms.txt)[https://raw.githubusercontent.com/google/A2A/main/llms.txt] (分數: 0.62)
- operability
9. AI agents
10. Agent communication standard


- [index.md](https://raw.githubusercontent.com/google/A2A/main/docs/index.md)：代理對代理 (A2A) 協定文件
代理對代理 (A2A) 協定是一個開放標準，可實現基於不同框架和由不同供應商建置的 AI 代理之間的無縫通訊和協作。它提供了一種通用語言，打破了孤島並促進了互通性。A2A 促進了代理之間作為對等點的動態、多模態通訊，允許它們委派子任務、交換資訊並協調行動以解決複雜問題。該協定透過使代理能夠在不共享內部記憶體、工具或專有邏輯的情況下進行互動來確保安全並保護智慧財產權。要開始使用，使用者可以閱讀介紹、深入了解規格、遵循教學或探索程式碼範例。

文件中沒有明確提供程式碼範例；但是，該文件引用了一個 Python 快速入門教學：
```markdow

#### (google/A2A/docs/specification/details.md)[https://raw.githubusercontent.com/google/A2A/main/docs/specification/details.md] (分數: 0.62)
-

代理對代理 (A2A) 協定是一個開放標準，旨在促進獨立、可能不透明的 AI 代理系統之間的通訊和互通性。在一個代理可能使用不同框架、語言或供應商建置的生態系統中，A2A 提供了一種通用語言和互動模型。這使得代理能夠發現彼此的能力、協商互動模式（文字、檔案、結構化資料）、管理協作任務以及安全地交換資訊以實現使用者目標 **而無需存取彼此的內部狀態、記憶體或工具。**

**主要目標：**

- **互通性：** 彌合不同代理系統之間的差距。
- **協作：** 使代理能夠委派任務、交換上下文並在複雜的使用者請求上共同合作。
- **發現：** 允許代理動態尋找和理解其他代理的能力。
- **靈活性：** 支援各種互動模式（文字、檔案、表單、串流）。
- **安全性：** 促進適合企業環境的安全通訊模式。
- **非同步性：** 支援可能涉及人在迴圈情境的長時間執行任務和互動。

本文件提供了 A2A 協定的詳細技術規格，定義了其資料結構、通訊方法和核心概念。

#

#### (google/A2A/docs/community.md)[https://raw.githubusercontent.com/google/A2A/main/docs/community.md] (分數: 0.62)
-

**代理對代理 (A2A) 協定** 正在科技界引起極大的關注，這是有充分理由的！這個開放的互通性協定旨在實現 **跨不同框架和供應商的 AI 代理之間的無縫協作**。透過標準化通訊，A2A 旨在解鎖複雜的工作流程、提高生產力並培養一個**「代理互通性」**的新時代。不要只聽我們說 – 看看社群是怎麼說的！


#### (google/A2A/docs/topics/a2a-and-mcp.md)[https://raw.githubusercontent.com/google/A2A/main/docs/topics/a2a-and-mcp.md] (分數: 0.60)
- A2A)

- **焦點：** A2A 標準化了獨立、通常不透明的 **AI 代理如何作為對等點進行通訊和協作。**
- **機制：** 它為代理提供了一個應用程式級協定，以便：
    - 發現彼此的高階技能和能力（透過代理卡）。
    - 協商互動模式（文字、檔案、結構化資料）。
    - 管理共享、有狀態且可能長時間執行的任務。
    - 交換對話上下文、指令和複雜、多部分的結果。
- **使用案例：**
    - 客戶服務代理將複雜的帳單查詢委派給專門的帳單代理，並維護客戶互動的上下文。
    - 旅遊規劃代理與獨立的航班、飯店和活動預訂代理協調，管理多階段預訂流程。
    - 代理交換隨時間演變的協作專案的資訊和狀態更新。
- **與工具互動的主要區別：** A2A 允許比通常在簡單工具呼叫中看到的更動態、有狀態且可能多模態的互動。使用 A2A 的代理*作為代理*（或代表使用者）進行通訊，而不僅僅是呼叫一個離散的函式。

#### (google/A2A/docs/topics/enterprise-ready.md)[https://raw.githubusercontent.com/google/A2A/main/docs/topics/enterprise-ready.md] (分數: 0.60)
-

代理對代理 (A2A) 協定的設計核心是企業需求。A2A 並非發明新的專有安全和營運標準，而是旨在與現有的企業基礎設施和廣泛採用的最佳實踐無縫整合。A2A 將遠端代理視為標準的、基於 HTTP 的企業應用程式。這種方法使組織能夠利用其在安全性、監控、治理和身份管理方面的現有投資和專業知識。

A2A 的一個關鍵原則是代理通常是「不透明的」——它們不與彼此共享內部記憶體、工具或直接資源存取權。這種不透明性自然地與標準的客戶端/伺服器安全範例保持一致。


#### (google/A2A/docs/topics/what-is-a2a.md)[https://raw.githubusercontent.com/google/A2A/main/docs/topics/what-is-a2a.md] (分數: 0.60)
-

採用 A2A 可以帶來顯著的優勢：

- **增強的互通性：** 打破不同 AI 代理生態系統之間的孤島，允許來自不同供應商和框架的代理協同工作。
- **增強的代理能力：** 允許開發人員透過組合多個專業代理的優勢來建立更複雜的應用程式。
- **降低整合複雜性：** 標準化代理通訊的「方式」，讓團隊能夠專注於「什麼」——他們的代理提供的價值。
- **促進創新：** 鼓勵開發更豐富的專業代理生態系統，這些代理可以隨時插入更大的協作工作流程。
- **面向未來：** 提供一個靈活的框架，可以隨著代理技術的不斷發展而調整。

透過為代理對代理通訊建立共同基礎，A2A 旨在加速 AI 代理在不同行業和應用中的採用和實用性，為更強大和協作的 AI 系統鋪路。

[觀看 A2A 示範影片](https://storage.googleapis.com/gweb-developer-goog-blog-assets/original_videos/A2A_demo_v4.mp4)

接下來，了解構成 A2A 協定基礎的[關鍵概念](./key-concepts.md)
-

A2A 為這些獨立、通常「不透明」（黑箱）的代理系統提供了一種標準化的互動方式。它定義了：

- **通用傳輸和格式：** 用於訊息結構和傳輸的 HTTP(S) 上的 JSON-RPC 2.0。
- **發現機制（代理卡）：** 代理如何宣傳其能力並被其他代理發現。
- **任務管理工作流程：** 如何啟動、進展和完成協作任務。這包括對可能長時間執行或需要多輪互動的任務的支援。
- **支援各種資料模式：** 代理如何不僅交換文字，還交換檔案、結構化資料（如表單）以及可能其他富媒體。
- **安全和非同步的核心原則：** 安全通訊和處理可能需要大量時間或涉及人在迴圈流程的任務的指南。

#

#### (google/A2A/docs/llms.txt)[https://raw.githubusercontent.com/google/A2A/main/docs/llms.txt] (分數: 0.60)
-

*   **專案名稱：** 代理對代理 (A2A) 協定
*   **目的：** 一個由 Google 發布的開放協定，可實現基於不同框架或由不同供應商建置的 AI 代理之間的通訊和互通性。
*   **核心目標：** 允許代理發現能力、協商互動並安全地協作執行任務。
*   **通訊：** 使用基於 HTTP(S) 的 JSON-RPC 2.0。支援標準請求/回應和用於串流的伺服器發送事件 (Server-Sent Events, SSE)。
*   **主要元件：** 規格（JSON 結構描述）、通用函式庫（Python、JS/TS）、範例代理（LangGraph、CrewAI、ADK、Genkit）、範例主機（CLI、協同器）、示範 Web 應用程式（Mesop）。

#

步驟 1<思考>
思考:
- 先前的回應提供了對 A2A 協定的全面解釋。它非常詳細，似乎涵蓋了協定的大部分方面。
- 由於已獲得的資訊足以徹底回答問題，因此無需呼叫任何其他工具。
</思考>

<選定的工具>
[]
</選定的工具>

<答案>
A2A (Agent2Agent) 協定是由 Google 發起的一項開放標準，旨在實現不同 AI 代理系統之間的通訊和互通性。其核心目標是讓建立在不同框架或由不同供應商提供的代理能夠發現彼此的能力、協商互動方法（文字、檔案、結構化資料，未來可能還有音訊/視訊），並在任務上進行協作。

主要功能包括：

* **代理發現：** 代理透過代理卡發現彼此的能力，通常位於 `/.well-known/agent.json`。
* **標準化任務管理：** 用於管理任務（傳送、取得、取消）的標準化工作流程。
* **支援各種內容類型：** 透過 `Parts` 和 `Artifacts`（文字、檔案、結構化資料）支援各種內容類型。
* **串流更新：** 使用伺服器發送事件 (SSE) 支援長時間執行任務的串流更新。
* **推播通知：** 提供推播通知機制，讓客戶端保持更新。
* **基於 HTTP(S) 的 JSON-RPC 2.0：** 使用基於 HTTP(S) 的 JSON-RPC 2.0 進行通訊，支援標準請求/回應和 SSE 串流。

該協定由一個 JSON 結構描述定義，並提供 Python 和 JavaScript/TypeScript 的支援函式庫和範例實作。這些範例展示了與各種代理框架（LangGraph、CrewAI、Google ADK、Genkit）的整合，並包括範例代理、主機和一個示範網頁應用程式。該協定還考慮了安全性和企業應用的準備。
</答案>
</代理>
<思考>
思考:
- 「什麼是 A2A 協定？」這個問題已經由 A2A 協定代理全面回答了。
- 不需要更多的代理。提供的答案已經足夠了。
</思考>

<選定的代理>
```json
[]
```
</選定的代理>

<答案>
A2A 協定代理的回應提供了 A2A 協定的完整而準確的定義，包括其主要功能和特性。不需要進一步的資訊。
</答案>